.. _generic:

generic: Preprocess a generic source file
=========================================

**Package: softools**

.. raw:: html

  <section id="s_usage">
  <h3>Usage</h3>
  <p>
  generic [-k] [-o ofile] [-p prefix] [-t types] files
  </p>
  </section>
  <section id="s_parameters">
  <h3>Parameters</h3>
  <dl>
  <dt><b>-k</b></dt>
  <!-- Sec='PARAMETERS' Level=0 Label='' Line='-k' -->
  <dd>Allow the output files generated by <i>generic</i> to clobber any existing
  files.
  </dd>
  </dl>
  <dl>
  <dt><b>-o ofile</b></dt>
  <!-- Sec='PARAMETERS' Level=0 Label='' Line='-o ofile' -->
  <dd>The name of the output file.  If this option is selected, only a single
  file can be processed.
  </dd>
  </dl>
  <dl>
  <dt><b>-p prefix</b></dt>
  <!-- Sec='PARAMETERS' Level=0 Label='' Line='-p prefix' -->
  <dd>A prefix to be prepended to the output filenames.  This is useful when
  the output files are to be placed in a different directory.
  </dd>
  </dl>
  <dl>
  <dt><b>-t types</b></dt>
  <!-- Sec='PARAMETERS' Level=0 Label='' Line='-t types' -->
  <dd>The datatypes for which output is desired.  One output file will be generated
  for each type specified, with <i>generic</i> automatically generating the
  output filename by appending the type character to the root filename of
  the input file.  The <i>type</i> string is some subset of [ubscilrdx],
  where the type characters are as follows.
  <div class="highlight-default-notranslate"><pre>
  u       - C unsigned short
  b       - C byte (char)
  c       - SPP character
  s       - SPP short
  i       - SPP int
  l       - SPP long
  r       - SPP real
  d       - SPP double
  x       - SPP complex
  </pre></div>
  This option cannot be used in combination with the -o option, and should
  not be used when generic code is expanded inline, rather than written into
  multiple output files.
  </dd>
  </dl>
  <dl id="l_files">
  <dt><b>files</b></dt>
  <!-- Sec='PARAMETERS' Level=0 Label='files' Line='files' -->
  <dd>The input file or files to be processed.  Generic input files should have
  the extension <span style="font-family: monospace;">".gx"</span> or <span style="font-family: monospace;">".gc"</span>, although this is not required.  Only a single
  input file can be given if the -o option is specified.
  </dd>
  </dl>
  </section>
  <section id="s_description">
  <h3>Description</h3>
  <p>
  The generic preprocessor is used to translate generic source code (code
  written to work for any datatype) into type dependent source code,
  suitable for compilation and insertion into a library.  The generic source
  is translated for each datatype, producing a type dependent copy of the
  source code for each datatype.  There are two primary modes of operation:
  </p>
  <dl>
  <dt><b></b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='' Line=' ' -->
  <dd><dl>
  <dt><b>[1]</b></dt>
  <!-- Sec='DESCRIPTION' Level=1 Label='' Line='[1]' -->
  <dd>The generic source is embedded in a normal file, bracketed by <i>$for</i> and
  <i>$endfor</i> directives.  There is one input file and one somewhat larger
  output file, with the generic code in the input file being replaced in the
  output file by several copies of the enclosed source, one for each datatype.
  This mode is most commonly used for modules to be linked in their entirety 
  into an applications package.  The <span style="font-family: monospace;">"-o"</span> parameter is used to specify
  the output filename.
  </dd>
  </dl>
  <dl>
  <dt><b>[2]</b></dt>
  <!-- Sec='DESCRIPTION' Level=1 Label='' Line='[2]' -->
  <dd>The entire input file is generic.  There may be multiple input files, and
  for each input file N output files are generated, one for each datatype
  specified with the <span style="font-family: monospace;">"-t"</span> parameter.  The output filenames are automatically
  generated by appending the type character to the root filename of the
  input file.  This mode is most commonly used for object libraries.
  </dd>
  </dl>
  </dd>
  </dl>
  <p>
  The generic preprocessor operates by token replacement (currently using a
  UNIX <i>Lex</i> lexical analyzer).  The input stream is broken up into a
  stream of tokens.  Each token is examined to see if it is in the following
  list, and the indicated action is taken if the token is matched.  The generic
  preprocessor directives have the form <span style="font-family: monospace;">"$NAME"</span>, where $ marks a <i>generic</i>
  directive, and where NAME is the name of the directive.
  </p>
  <dl id="l_PIXEL">
  <dt><b>PIXEL</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='PIXEL' Line='PIXEL' -->
  <dd>Replaced by the current type name, e.g., <span style="font-family: monospace;">"int"</span>, <span style="font-family: monospace;">"real"</span>, etc.
  </dd>
  </dl>
  <dl id="l_XPIXEL">
  <dt><b>XPIXEL</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='XPIXEL' Line='XPIXEL' -->
  <dd>Replaced by the current type name in upper case, preceded by an X,
  e.g., <span style="font-family: monospace;">"XINT"</span>, <span style="font-family: monospace;">"XREAL"</span>, etc.  This is used for generic C procedures meant
  to be called from SPP or Fortran.
  </dd>
  </dl>
  <dl id="l_INDEF">
  <dt><b>INDEF</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='INDEF' Line='INDEF' -->
  <dd>Replaced by the numeric constant denoting indefinite for the current
  datatype.
  </dd>
  </dl>
  <dl id="l_INDEF">
  <dt><b>INDEF[SILRDX]</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='INDEF' Line='INDEF[SILRDX]' -->
  <dd>These strings are <i>not</i> replaced, since the <span style="font-family: monospace;">"INDEF"</span> in this case is
  not generic.
  </dd>
  </dl>
  <dl id="l_SZ_PIXEL">
  <dt><b>SZ_PIXEL</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='SZ_PIXEL' Line='SZ_PIXEL' -->
  <dd>Replaced by <span style="font-family: monospace;">"SZ_INT"</span>, <span style="font-family: monospace;">"SZ_REAL"</span>, etc.
  </dd>
  </dl>
  <dl id="l_TY_PIXEL">
  <dt><b>TY_PIXEL</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='TY_PIXEL' Line='TY_PIXEL' -->
  <dd>Replaced by <span style="font-family: monospace;">"TY_INT"</span>, <span style="font-family: monospace;">"TY_REAL"</span>, etc.
  </dd>
  </dl>
  <dl>
  <dt><b>$PIXEL</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='' Line='$PIXEL' -->
  <dd>Replaced by the string <span style="font-family: monospace;">"PIXEL"</span>.  This is used in doubly generic sources,
  where the first pass translates $PIXEL to PIXEL, and the second to the
  actual type string.
  </dd>
  </dl>
  <dl>
  <dt><b>$INDEF</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='' Line='$INDEF' -->
  <dd>Replaced by the string <span style="font-family: monospace;">"INDEF"</span>.
  </dd>
  </dl>
  <dl>
  <dt><b>$t</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='' Line='$t' -->
  <dd>Replaced by one of the characters [ubcsilrdx].
  </dd>
  </dl>
  <dl>
  <dt><b>$T</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='' Line='$T' -->
  <dd>Replaced by one of the characters [UBCSILRDX].
  </dd>
  </dl>
  <dl>
  <dt><b>$/.../</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='' Line='$/.../' -->
  <dd>Replaced by the string <span style="font-family: monospace;">"..."</span>, i.e., whatever is within the // delimiters.
  Used to disable generic preprocessing of arbitrary text.
  </dd>
  </dl>
  <dl>
  <dt><b>[0-9]+(<span style="font-family: monospace;">"$f"</span>|<span style="font-family: monospace;">"$F"</span>)</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='' Line='[0-9]+("$f"|"$F")' -->
  <dd>Replaced by the corresponding real or double constant.  For example,
  <span style="font-family: monospace;">"1$f"</span> translates as <span style="font-family: monospace;">"1.0"</span> for type real, but as <span style="font-family: monospace;">"1.0D0"</span> for type double.
  </dd>
  </dl>
  <dl>
  <dt><b>$if (expression)</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='' Line='$if (expression)' -->
  <dd>The conditional preprocessing facility.  If the $IF tests false the code
  which follows is skipped over, and is not copied to the output file.
  Control transfers to the matching $ELSE or $ENDIF.  The following may be
  used in the boolean expression:
  <div class="highlight-default-notranslate"><pre>
  "datatype"      denotes the current type
  ubcsilrdx       any subset of these characters denotes
                      the corresponding datatype
  sizeof()        the size of the specified type,
                      e.g., for comparisons
  
  != ==           the relational operators
   &gt;  &lt;  &gt;= &lt;=
  
  Examples:
  
          $if (datatype != dx)
              (code to be compiled if type not d or x)
  
          $if (sizeof(i) &lt;= sizeof(r))
              (code to be compiled if size int &lt;= real)
  </pre></div>
  $IF constructs may be nested.  The directive may appear anywhere on
  a line.
  </dd>
  </dl>
  <dl>
  <dt><b>$else</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='' Line='$else' -->
  <dd>Marks the else clause of a $IF.
  </dd>
  </dl>
  <dl>
  <dt><b>$endif</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='' Line='$endif' -->
  <dd>Marks the end of a $IF.  One is required for every $IF.
  </dd>
  </dl>
  <dl>
  <dt><b>$for (types)</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='' Line='$for (types)' -->
  <dd>For each of the listed types, output a translated copy of the code between
  the $FOR and the matching $ENDFOR.  Nesting is permitted.
  <div class="highlight-default-notranslate"><pre>
  Example:
          $for (silrd)
          (any amount of generic code)
          $endfor
  </pre></div>
  </dd>
  </dl>
  <dl>
  <dt><b>$endfor</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='' Line='$endfor' -->
  <dd>Marks the end of a $FOR statement.
  </dd>
  </dl>
  <dl>
  <dt><b>$$</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='' Line='$$' -->
  <dd>Replaced by a single $.
  </dd>
  </dl>
  <dl>
  <dt><b>/*...*/</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='' Line='/*...*/' -->
  <dd>C comments are not preprocessed.
  </dd>
  </dl>
  <dl>
  <dt><b><span style="font-family: monospace;">"..."</span></b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='' Line='"..."' -->
  <dd>Quoted strings are not preprocessed.
  </dd>
  </dl>
  <dl>
  <dt><b>#...(EOL)</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='' Line='#...(EOL)' -->
  <dd>SPP comments are not preprocessed.
  </dd>
  </dl>
  <dl>
  <dt><b>%...(EOL)</b></dt>
  <!-- Sec='DESCRIPTION' Level=0 Label='' Line='%...(EOL)' -->
  <dd>SPP Fortran escapes are not preprocessed.
  </dd>
  </dl>
  </section>
  <section id="s_examples">
  <h3>Examples</h3>
  <p>
  1. Translate the generic source <span style="font-family: monospace;">"aadd.gx"</span> to produce the six output files
  <span style="font-family: monospace;">"aadds.x"</span>, <span style="font-family: monospace;">"aaddi.x"</span>, etc., in the subdirectory <span style="font-family: monospace;">"ak"</span>, clobbering any
  existing files therein.  The <i>generic</i> task is a bootstrap utility
  written in C and is implemented as a CL foreign task, hence the UNIX
  command syntax.
  </p>
  <div class="highlight-default-notranslate"><pre>
  cl&gt; generic -k -p ak/ -t silrdx aadd.gx
  </pre></div>
  <p>
  2. Perform an inline transformation ($FOR directive) of the source file
  <span style="font-family: monospace;">"imsum.gx"</span>, producing the single file <span style="font-family: monospace;">"imsum.x"</span> as output.
  </p>
  <div class="highlight-default-notranslate"><pre>
  cl&gt; generic -k -o imsum.x imsum.gx
  </pre></div>
  <p>
  3. The following is a simple example of a typical generic source file.
  For additional examples, see the <span style="font-family: monospace;">".gx"</span> sources in the VOPS, IMIO, IMAGES
  and other directories.
  </p>
  <div class="highlight-default-notranslate"><pre>
  # ALIM -- Compute the limits (minimum and maximum values) of a vector.
  # (this is a copy of the file vops$alim.gx).
  
  procedure alim$t (a, npix, minval, maxval)
  
  PIXEL   a[ARB], minval, maxval, value
  int     npix, i
  
  begin
          minval = a[1]
          maxval = a[1]
  
          do i = 1, npix {
              value = a[i]
              $if (datatype == x)
                  if (abs(value) &lt; abs(minval))
                      minval = value
                  else if (abs(value) &gt; abs(maxval))
                      maxval = value
              $else
                  if (value &lt; minval)
                      minval = value
                  else if (value &gt; maxval)
                      maxval = value
              $endif
          }
  end
  </pre></div>
  </section>
  <section id="s_see_also">
  <h3>See also</h3>
  <p>
  xc, xyacc
  </p>
  
  </section>
  
  <!-- Contents: 'NAME' 'USAGE' 'PARAMETERS' 'DESCRIPTION' 'EXAMPLES' 'SEE ALSO'  -->
  
